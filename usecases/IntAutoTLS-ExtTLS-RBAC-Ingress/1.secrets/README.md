# Secrets

[![en](https://img.shields.io/badge/lang-en-red.svg)](https://github.com/ogomezso/cfk-runbooks/blob/main/usecases/IntAutoTLS-ExtTLS-RBAC-Ingress/1.secrets/README.md)
[![es](https://img.shields.io/badge/lang-es-yellow.svg)](https://github.com/ogomezso/cfk-runbooks/blob/main/ussescases/IntAutoTLS-ExtTLS-RBAC-Ingress/1.secrets/README.es.md)

On this section we gonna go through the different K8s secrets we will need to put in place for our use case deployment

## Way of working

- Use local files provided on `1.secrets` as base to generate the K8s secrets
- Base on that we are going to dynamically create the yaml resource file for the secret using `kubectl` commands:

```bash
kubectl create secret <specific secret config> --dry-run:client -o yaml > <client-secret-name>.yaml
```

- On file based secret creation is important to take care of the destination file name since operator can only search for specific ones. This name is the one your provide on the left side of `from-file=` field of the kubectl command

## TLS secrets

We will need two secrets for internal and external tls configuration:

### Internal

As we already saw on the `certificates` section autogenerated secret is managed by `Confluent Operator` itself.

So we will need to create a `tls` kind of secret with the exact name of `ca-pair-sslcerts`:

Generate the resource file:

```bash
kubectl create secret tls ca-pair-sslcerts \
--cert=generated/InternalCAcert.pem \
--key=generated/InternalCAkey.pem \
-n confluent --dry-run=client -output yaml > ca-pair-sslcerts.yaml
```

and finally apply it:

```bash
kubectl apply -f ca-pair-sslcerts.yaml
```

### External

For external access we would need two kinds of secret depending on the Ingress Controller ssl passthrough capabilities:

One which will be use for the operator to create the appropriate certificate stores on component side:

```bash
kubectl create secret generic kafka-external-tls \
  --from-file=fullchain.pem=generated/externalKafka.pem \
  --from-file=privkey.pem=generated/externalKafka-key.pem \
  --from-file=cacerts.pem=generated/ExternalCAcert.pem \
  --namespace confluent --dry-run:client -o yaml > kafka-external-tls.yaml
```

and another for Ingress configuration in case of need:

```bash
kubectl create secret tls services-external-tls \
  --cert=generated/externalServices.pem \
  --key=generated/externalServices-key.pem \
  --namespace confluent --dry-run_client -o yaml > services-external-tls.yaml
```

## Zookeeper

On this use case example `Zookeeper` service is implemented with `autogenerated certs` for connections (note that Kafka Brokers are the only client that zookeeper should have) and `digest` for authentication type.

For tls secret we just need to enable the `tls autogenerated` configuration and operator will use the already created `ca-pair-sslcerts`

For digest user we need to use a json file (provided as `zk-digest-cred.json` on this folder) as source for user information:

```json
{
    "zk": "zk-secret"
}
```

and generate the resource file from it:

```bash
kubectl create secret generic zk-digest \
  --from-file=digest-users.json=zk-digest-cred.json \
  --namespace confluent --dry-run:client -o yaml > zk-digest.yaml
```

## Broker

On this example `Kafka Brokers` will use a variety of secrets depending on the use:

### Internal Communication

For **internal tls**  secret we just need to enable the `tls autogenerated` configuration and operator will use the already created `ca-pair-sslcerts`

For **Replication (interbroker communication)** we will need a  `SASL JaaS config` file based secret:

```conf
sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
  username="admin" password="admin-secret" \
  user_kafka="kafka-secret" user_admin="admin-secret";
```

On these configuration we are setting up the `admin` user as server user for `interbroker` communication and advertising that there are two possible users that can connect to Kafka: admin itself with password `admin-secret` and `kafka` user with password `kafka-secret` that will be the one that other components will use.

